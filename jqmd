#!/usr/bin/env bash

# LICENSE
# -------
#
# `jqmd` is copyright 2017 PJ Eby,
# and MIT-licensed as follows:
#
# Permission is hereby granted, free of
# charge, to any person obtaining a copy
# of this software and associated
# documentation files (the "Software"),
# to deal in the Software without
# restriction, including without
# limitation the rights to use, copy,
# modify, merge, publish, distribute,
# sublicense, and/or sell copies of the
# Software, and to permit persons to
# whom the Software is furnished to do
# so, subject to the following
# conditions:
#
# The above copyright notice and this
# permission notice shall be included in
# all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS",
# WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT OWNERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

set -euo pipefail
source "$(command -v mdsh)"

jqmd-runtime() { # --- jqmd runtime begins
RUN_JQ() {
    local opt nargs cmd=(jq) opts=("${JQOPTS[@]:1}" "$@")

    while (("${#opts[@]}")); do
        opt="${opts[0]}"
        case "$opt" in
        -{f,-fromfile})                     nargs=2 ; FILTER <"${opts[1]}" ;;
        -{L,-indent})                       nargs=2 ;;
        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;
        --)  break   ;; # rest of args are data files
        -*)  nargs=1 ;;
        *)   FILTER "$opt"; break ;; # jq program: data files follow
        esac
        cmd+=("${opts[@]:0:$nargs}")    # add $nargs args to cmd
        opts=("${opts[@]:$nargs}")      # shift $nargs args off opts
    done

    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression

    opts[0]=n/a; "${cmd[@]}" -f <(
        printf "%s\n" "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"
    ) "${opts[@]:1}"

    CLEAR_FILTERS   # cleanup for any re-runs
}

export-dotenv() {
    local before="" after=""
    before="$(compgen -v)"; source "$@"; after="$(compgen -v)"
    after="$(echo "$after" | grep -vxF -f <(echo "$before"))" || true
    [[ -z "$after" ]] || export $after
}

command -v yaml2json >/dev/null || yaml2json() {
    python -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)';
}

HAVE_FILTERS() { [[ ${jqmd_filters-} ]]; }
CLEAR_FILTERS() { unset jqmd_filters; }

JQOPTS=(jq)
JQ_OPTS() { JQOPTS+=("$@"); }

ARG()     { JQ_OPTS --arg     "$1" "$2"; }
ARGJSON() { JQ_OPTS --argjson "$1" "$2"; }

jqmd_imports=
jqmd_filters=
jqmd_defines=

IMPORTS() { jqmd_imports+="${jqmd_imports:+$'\n'}$1"; }
DEFINE()  { jqmd_defines+="${jqmd_defines:+$'\n'}$1"; }
FILTER()  { jqmd_filters+="${jqmd_filters:+|}$1"; }

YAML()    { JSON "$(echo "$1" | yaml2json -)"; }
JSON()    { FILTER "jqmd_data($1)"; }

}; jqmd-runtime  # -- jqmd runtime ends


# mdsh compilation support
mdsh-compile-jq()   { printf 'jqmd_filters+="${jqmd_filters:+|}"%q\n' "$1"; }
mdsh-compile-yml()  { printf 'jqmd_filters+="${jqmd_filters:+|}"%q\n' "jqmd_data($(echo "$1" | yaml2json -))"; }
mdsh-compile-yaml() { printf 'jqmd_filters+="${jqmd_filters:+|}"%q\n' "jqmd_data($(echo "$1" | yaml2json -))"; }
mdsh-compile-json() { printf 'jqmd_filters+="${jqmd_filters:+|}"%q\n' "jqmd_data($1))"; }

# Change --compile and --eval to include the jqmd runtime and RUN_JQ logic
eval "mdsh.--compile() $(mdsh-rewrite mdsh.--compile '{ jqmd-header' ' jqmd-footer; }')"

jqmd-header() { mdsh-rewrite jqmd-runtime; }
jqmd-footer() { echo 'if [[ $0 == $BASH_SOURCE ]] && HAVE_FILTERS; then RUN_JQ; fi'; }


# check bash-source and run main only if directly executing
if [[ $0 == $BASH_SOURCE ]]; then
    mdsh-main "$@"
fi

